## 9. 自動開発フロー全体設計

### 核心思想

> **自然言語で全てを設計してから、コードに起こす。**
> 作業者（エージェント）がやることが100%明確になり、判断で迷わない。

### 完全な流れ（ステップバイステップ）

```
[あなた] 要件定義書を渡す
    ↓
[エージェント] /full-auto-dev ワークフローを実行
    ↓
──────── 自然言語フェーズ（コードなし） ────────
    ↓
[Phase 1] 要件分析 & DDDリスト作成
    ↓
[Phase 2] 自然言語で全体設計
    - アーキテクチャ・関数リスト・共通化・コンポーネントリスト
    ↓
[Phase 3] 実装タスクリスト & parts 計画
    ↓
★ 実行プラン（自然言語設計書）を表示 → 確認
    ↓
──────── コードフェーズ（繰り返し） ────────
    ↓
[Phase 4] parts ブランチで個別 TDD
    - dev → parts/user-repository で TDD
    - dev → parts/order-service で TDD
    - dev → parts/user-form で TDD
    - 失敗時は self-growth スキルが自動発動
    - 全テスト通過で dev にマージ（パーツがただ集まる）
    ↓
[Phase 5] build ブランチで組立
    - dev → build でパーツを組み立てる
    - 結合テストを書いて通す
    - dev にマージして機能完成
    ↓
    ↻ Phase 4-5 を全機能完成まで繰り返し
    ↓
[Phase 6] lint / 型 / セキュリティチェック
    ↓
[エージェント] ウォークスルーで最終報告
    - 自然言語設計書 vs 実装の対応表
    - テスト結果
    ↓
──────── ここから先は手動（スコープ外） ────────
    ↓
[あなた] qa ブランチでテスト
    ↓
[あなた] main にマージしてデプロイ 🎉
```

### Git ブランチ戦略

```
main   ← 本番デプロイ
  │
  └── qa    ← テスト環境
       │
       └── dev   ← 開発環境（自動化のスコープはここまで）
            │
            ├── build                ← dev派生。パーツを組み立てる場所
            ├── parts/user-entity    ← dev派生。クラス単位
            ├── parts/user-repo      ← dev派生。クラス単位
            ├── parts/order-service   ← dev派生。関数単位
            ├── parts/user-form      ← dev派生。コンポーネント単位
            └── parts/button         ← dev派生。共通コンポーネント
```

**サイクル:**

```
dev → parts/* で個別TDD → dev にマージ（パーツがただ集まる）
 → build でパーツ組立 → dev にマージ（機能完成）
 → 繰り返し
```

**ルール:**

- `parts/*` はクラス・関数・コンポーネント単位で切る
- `parts/*` 内で TDD サイクルを回し、全テスト通過後に `dev` へマージ
- `build` で集まったパーツを組み立てて動く機能にする
- `qa` 以降は手動（スコープ外）
