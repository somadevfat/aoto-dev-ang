# 🚀 自動開発プロセス構築ガイド

> **目的**: 要件定義書のみを渡したら、人間によるセキュリティチェック・デプロイを除き、コードレビューなしで完成状態のアプリが出来上がる環境を、Antigravity の機能を最大限に活かして構築する。

---

## 📋 目次

1. [全体像](#1-全体像)
2. [環境構築の前提条件](#2-環境構築の前提条件)
3. [ルール (Rules) の構築](#3-ルール-rules-の構築)
4. [スキル (Skills) の構築](#4-スキル-skills-の構築)
5. [ワークフロー (Workflows) の構築](#5-ワークフロー-workflows-の構築)
6. [並列実行 (Parallel Execution) 戦略](#6-並列実行-parallel-execution-戦略)
7. [ナレッジアイテム (Knowledge Items) の活用](#7-ナレッジアイテム-knowledge-items-の活用)
8. [MCP 統合](#8-mcp-統合)
9. [自動開発フロー全体設計](#9-自動開発フロー全体設計)
10. [あなたがやるべきこと（チェックリスト）](#10-あなたがやるべきことチェックリスト)
11. [参考情報](#11-参考情報)

---

## 1. 全体像

### ゴール

```
要件定義書 (Markdown)
    ↓
エージェントが自動で以下を実行
    ↓
┌─────────────────────────────────────────────┐
│ 1. 要件分析 & DDD リスト作成              │
│ 2. 自然言語でアーキテクチャ全体設計        │
│ 3. 自然言語でクラス・関数・コンポーネント設計│
│    （共通化もこの段階で実施）              │
│ 4. parts ブランチで個別 TDD               │
│ 5. dev にマージ → build で組立 → dev      │
│ 6. 4-5 を繰り返して dev 上で機能完成      │
│ ※ qa・main（テスト・デプロイ）は手動       │
└─────────────────────────────────────────────┘
```

### 使う Antigravity 機能

| 機能                         | 役割                                           |
| :--------------------------- | :--------------------------------------------- |
| **ルール**                   | 常に守るべき制約（設計原則、コーディング規約） |
| **スキル**                   | 特定タスクの実行手順をパッケージ化             |
| **ワークフロー**             | 開発フロー全体の手順を定義                     |
| **並列実行**                 | 複数エージェントで独立タスクを同時処理         |
| **ナレッジ**                 | 過去の知見を蓄積・自動参照                     |
| **MCP**                      | 外部サービス連携（DB、GitHub等）               |
| **ブラウザサブエージェント** | E2Eテスト・UI検証                              |
| **タスクグループ**           | 大規模タスクの分割管理                         |
| **実行プラン**               | 実装前のレビュー（初回のみ確認、以降自動）     |

---

## 2. 環境構築の前提条件

### ディレクトリ構造

```
anti-qol/
├── .agent/
│   ├── rules/              # ワークスペースルール
│   │   ├── coding.md       # コーディング規約
│   │   ├── architecture.md # アーキテクチャ制約
│   │   ├── testing.md      # テスト方針
│   │   ├── security.md     # セキュリティ規約
│   │   └── lint.md         # Lint & コミットフック
│   ├── skills/             # ワークスペーススキル
│   │   ├── requirements-analysis/
│   │   │   └── SKILL.md
│   │   ├── tdd-implementation/
│   │   │   └── SKILL.md
│   │   ├── ddd-modeling/
│   │   │   └── SKILL.md
│   │   ├── clean-architecture/
│   │   │   └── SKILL.md
│   │   ├── e2e-testing/
│   │   │   └── SKILL.md
│   │   └── self-growth/
│   │       └── SKILL.md    # 自己成長・失敗学習
│   └── workflows/          # ワークフロー定義
│       ├── full-auto-dev.md
│       ├── tdd-cycle.md
│       └── e2e-verify.md
├── .learnings/              # 失敗ログ蓄積ディレクトリ
│   ├── raw/                 # 個別の失敗ログ
│   └── dictionary.md        # 索引付き対処辞書（自動生成）
├── guide/                   # 公式ドキュメント（既存）
├── 目的.md
└── 提案_自動開発プロセス構築ガイド.md
```

### 必要な設定

| 設定項目             | 推奨値                     | 理由                              |
| :------------------- | :------------------------- | :-------------------------------- |
| **レビューポリシー** | `Always Proceed`（開発時） | 自動実行のため承認待ちを排除      |
| **サンドボクシング** | ON                         | 安全性の確保                      |
| **ストリクトモード** | OFF（開発時）              | 自動化の妨げになるため開発時はOFF |

---

## 3. ルール (Rules) の構築

ルールは **常にエージェントが従うべき制約** です。  
`<root>/.agent/rules/` に配置します。

### 3.1 `coding.md` - コーディング規約

````markdown
---
description: コーディング規約と品質基準
globs: ["*.ts", "*.tsx", "*.js", "*.jsx"]
alwaysApply: true
---

# コーディング規約

## 技術スタック（固定）

- **ランタイム**: Bun
- **バックエンド**: ElysiaJS（型共有を最大限活用）
- **フロントエンド**: Next.js（App Router）
- **言語**: TypeScript（strict モード必須）
- DB は Repository パターンで抽象化し、後から変更可能にする

## JSDoc（必須）

すべての public 関数・クラス・メソッドに日本語 JSDoc を記述する。
以下の3項目を必ず含める:

1. **機能説明**: その関数/クラスが何をするか
2. **@param**: 各引数の型と説明
3. **@returns**: 戻り値の型と説明

```typescript
/**
 * ユーザーをIDで検索して返す
 * @param id - ユーザーの一意識別子
 * @returns 見つかったユーザー。存在しない場合は null
 */
async findById(id: string): Promise<User | null> { ... }
```
````

## コードスタイル

- 関数名・変数名は英語で記述
- コメントは日本語で記述
- 1ファイル200行以内を目安とする

## エラーハンドリング

- try-catch は必ず具体的なエラー型でキャッチ
- エラーメッセージは日本語で記述

````

### 3.2 `architecture.md` - アーキテクチャ制約

```markdown
---
description: アーキテクチャの制約と設計方針
alwaysApply: true
---

# アーキテクチャ制約

## 基本方針

- クリーンアーキテクチャを基本とする
- ドメインがある場合はDDDを適用する
- DDD適用時は **Context（機能）ベース** でディレクトリを分割する
- レイヤー間の依存は内側→外側のみ

## Context ベースの構造（DDD適用時）

機能（境界づけられたコンテキスト）ごとにディレクトリを分け、
各コンテキスト内にレイヤーを持たせる:

```text
backend/src/
├── contexts/
│   ├── user/                 # ユーザー管理コンテキスト
│   │   ├── domain/           # エンティティ, VO, リポジトリIF
│   │   ├── application/      # ユースケース, DTO
│   │   ├── infrastructure/   # リポジトリ実装, 外部API
│   │   └── presentation/     # コントローラー, ルート
│   ├── order/                # 注文コンテキスト
│   │   ├── domain/
│   │   ├── application/
│   │   ├── infrastructure/
│   │   └── presentation/
│   └── shared/               # 共有カーネル（共通型・ユーティリティ）
│       ├── domain/
│       └── infrastructure/
└── main.ts                   # ElysiaJS エントリポイント
````

フロントエンド（Next.js App Router）も同様に context ベース:

```text
frontend/src/
├── app/                      # App Router
│   ├── (auth)/               # 認証関連ルート
│   ├── (dashboard)/          # ダッシュボード関連ルート
│   └── layout.tsx
├── contexts/                 # 機能ベースモジュール
│   ├── user/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── types/
│   │   └── api/
│   └── order/
│       ├── components/
│       ├── hooks/
│       ├── types/
│       └── api/
└── shared/                   # 共通コンポーネント・ユーティリティ
```

## レイヤー間の制約

- Domain → 外部依存なし
- Application → Domain のみ依存
- Infrastructure → Domain, Application に依存
- Presentation → Application のみ依存
- Context 間の直接依存は禁止（shared 経由のみ）

## DB抽象化

- Repository パターンを使用
- インターフェースを各 Context の Domain 層に定義
- 実装を各 Context の Infrastructure 層に配置

````

### 3.3 `testing.md` - テスト方針

```markdown
---
description: テスト方針とTDDルール
alwaysApply: true
---

# テスト方針

## TDD ルール

- 実装コードを書く前に必ずテストを先に書く
- Red → Green → Refactor のサイクルを厳守
- テストタイトルは日本語で記述

## テストレベル

- **ユニットテスト** (主軸): 全ての関数・クラスに対して作成
- **E2Eテスト**: Playwright を使用し、主要なユーザーフローを検証

## カバレッジ

- ユニットテストカバレッジ 80% 以上を目標
- ドメインロジックは 100% カバー

## テストツール

- ユニットテスト: `bun test`（Bun 組み込みテストランナー）
- E2Eテスト: Playwright
````

### 3.4 `security.md` - セキュリティ規約

```markdown
---
description: セキュリティに関するコーディングルールとレビュー観点
alwaysApply: true
---

# セキュリティ規約

## 入力バリデーション

- 全てのユーザー入力を検証する（ElysiaJS の型バリデーション活用）
- SQLインジェクション・XSS対策を必ず施す
- パラメータはホワイトリスト方式でバリデーション

## 認証・認可

- 認証トークンはHTTP Only Cookie で管理
- パスワードは bcrypt 等でハッシュ化
- 全てのAPIエンドポイントに認可チェックを実装

## 機密情報

- シークレット情報はハードコードしない（.env 使用）
- .env ファイルは .gitignore に含める
- ログに機密情報を出力しない

## レビュー観点

実装時に以下のセキュリティチェックを自己レビューとして実施:

- [ ] 入力バリデーションは十分か
- [ ] 認可チェックは全APIに適用されているか
- [ ] 機密情報がコードに含まれていないか
- [ ] エラーメッセージに内部情報が漏洩していないか
- [ ] 依存パッケージに既知の脆弱性がないか
```

### 3.5 `lint.md` - Lint & コミットフック

````markdown
---
description: Lint設定とコミット時の自動チェック
alwaysApply: true
---

# Lint & コミットフック

## ESLint ルール

- `@typescript-eslint/no-explicit-any` を **error** に設定（any 禁止）
- `@typescript-eslint/strict` プリセットを使用
- import の自動ソートを有効化

## Husky + lint-staged

コミット時に以下を自動実行する:

1. **ESLint**: `*.ts`, `*.tsx` ファイルの lint チェック
2. **型チェック**: `tsc --noEmit` で型エラー検出
3. **スペルチェック**: `cspell` でスペルミス検出
4. **Prettier**: フォーマット統一

## セットアップ

プロジェクト初期化時に以下を設定:

```bash
bun add -d husky lint-staged eslint prettier cspell \
  @typescript-eslint/eslint-plugin @typescript-eslint/parser
bunx husky init
```
````

## .lintstagedrc.js 設定例

```javascript
module.exports = {
  "*.{ts,tsx}": ["eslint --fix", "prettier --write"],
  "*.{ts,tsx,md}": ["cspell --no-must-find-files"],
};
```

`````

---

## 4. スキル (Skills) の構築

スキルは **特定のタスクに対する実行手順** をパッケージ化したものです。
`<root>/.agent/skills/<スキル名>/SKILL.md` に配置します。

### 4.1 `requirements-analysis` - 要件分析スキル

````markdown
---
name: requirements-analysis
description: 要件定義書を分析し、DDDリスト・関数リスト・共通化まで自然言語レベルで完了する。要件定義書が渡されたときに使用。
---

# 要件分析スキル

## 実行タイミング

- 要件定義書（Markdown）が渡されたとき

## 核心思想

> **コードを1行も書く前に、自然言語ですべてを設計する。**
> 作業者（エージェント）がやることを100%明確にしてから、コードに起こす。

## 手順

### ステップ1: 要件の構造化

1. 要件定義書を読み込む
2. 以下を抽出する:
   - 機能要件（ユーザーストーリー形式に変換）
   - 非機能要件（性能、セキュリティ、スケーラビリティ）
   - ドメインの特定

### ステップ2: DDD リストの作成

要件定義の時点で DDDリスト を作成する:

1. Context（境界づけられたコンテキスト）の一覧
2. 各 Context 内のエンティティ・VO・ドメインサービス
3. Context 間の関係性（コンテキストマップ）

```text
## DDDリスト例

### Context: User（ユーザー管理）
- Entity: User（id, name, email, role）
- VO: Email（バリデーション付き）
- VO: UserId
- DomainService: UserAuthenticator
- Repository: UserRepository

### Context: Order（注文管理）
- Entity: Order（id, userId, items, status）
- VO: OrderId, OrderStatus
- Entity: OrderItem（productId, quantity, price）
- DomainService: OrderProcessor
- Repository: OrderRepository
```

### ステップ3: 関数単位への細分化 & 共通化

DDDリストの各要素をさらに **関数単位** にリストアップする。
この段階で **共通化できる関数** を自然言語の時点で特定する:

```text
## 関数リスト例

### shared/（共通）
- validateEmail(email: string): boolean — メール形式の検証
- generateId(): string — UUID生成
- formatDate(date: Date): string — 日付フォーマット

### Context: User
- createUser(name, email, role): User — ユーザー作成
- findUserById(id): User | null — ID検索
- updateUserRole(id, role): User — ロール変更
- authenticateUser(email, password): AuthToken — 認証

### Context: Order
- createOrder(userId, items): Order — 注文作成
- calculateTotal(items): number — 合計金額計算
- updateOrderStatus(id, status): Order — ステータス変更
```

### ステップ4: フロントエンド設計（自然言語）

フロントエンドも同様に自然言語で設計:

```text
## コンポーネントリスト

### shared/（共通コンポーネント ← 先に作成）
- Button — 汎用ボタン（variant: primary/secondary/danger）
- Input — 入力フィールド（バリデーション対応）
- Modal — モーダルダイアログ
- Table — テーブル表示
- Loading — ローディングスピナー

### Context: User（ページ: /users）
- UserList — ユーザー一覧表示
- UserDetail — ユーザー詳細
- UserForm — ユーザー作成/編集フォーム
- useUsers() — ユーザーデータ取得フック

### Context: Order（ページ: /orders）
- OrderList — 注文一覧
- OrderDetail — 注文詳細
- useOrders() — 注文データ取得フック
```

### ステップ5: 出力

分析結果を以下のフォーマットで出力:

```text
## 分析結果
- 設計手法: [クリーンアーキテクチャ / クリーンアーキテクチャ+DDD]
- Context 一覧: [リスト]
- DDDリスト: [上記の詳細]
- 関数リスト（共通化済み）: [上記の詳細]
- コンポーネントリスト（共通化済み）: [上記の詳細]
- parts ブランチ計画: [クラス/関数/コンポーネント単位のブランチ名リスト]
`````

```

```

### 4.2 `tdd-implementation` - TDD実装スキル

```markdown
---
name: tdd-implementation
description: TDD（テスト駆動開発）のRed-Green-Refactorサイクルに従ってコードを実装する。コード実装時に使用。
---

# TDD 実装スキル

## 実行タイミング

- コードの実装フェーズ

## 手順

### ステップ1: Red（失敗するテストを書く）

1. 実装するクラス/関数のインターフェースを定義
2. そのインターフェースに対するテストを書く
3. テストが **失敗する** ことを確認（`bun test` で実行）

### ステップ2: Green（テストを通す最小限のコードを書く）

1. テストを通すために必要な最小限の実装コードを書く
2. テストが **成功する** ことを確認
3. この段階では美しさは求めない

### ステップ3: Refactor（リファクタリング）

1. コードの重複を排除
2. 命名の改善
3. 設計パターンの適用
4. テストが引き続き **成功する** ことを確認

## 重要な制約

- 実装コードを書く前に必ずテストを先に書く
- 一度に1つのテストケースだけに集中する
- テストは日本語で命名する（例: `it('ユーザー名が空の場合エラーを返す')`)
```

### 4.3 `ddd-modeling` - DDDモデリングスキル

```markdown
---
name: ddd-modeling
description: ドメイン駆動設計に基づいてドメインモデルを設計する。ドメインが複雑と判断された場合に使用。
---

# DDD モデリングスキル

## 実行タイミング

- 要件分析でドメインが複雑と判断された場合

## 手順

### ステップ1: ユビキタス言語の定義

1. 要件定義書からドメイン用語を抽出
2. 用語集を作成（日本語 ⇔ コード上の英語名）

### ステップ2: 境界づけられたコンテキストの特定

1. サブドメインを特定
2. コンテキストマップを作成

### ステップ3: ドメインモデル設計

1. エンティティの特定（識別子を持つオブジェクト）
2. バリューオブジェクトの特定（不変オブジェクト）
3. 集約ルートの決定
4. ドメインサービスの特定
5. リポジトリインターフェースの定義

### ステップ4: 出力

- ドメインモデル図（Mermaid形式）
- Context 分割図
- 各 Context 内のエンティティ/VOの型定義ファイル
- リポジトリインターフェース
```

### 4.4 `clean-architecture` - クリーンアーキテクチャスキル

````markdown
---
name: clean-architecture
description: Contextベースのクリーンアーキテクチャ構造を生成する。プロジェクト初期構築時に使用。
---

# クリーンアーキテクチャスキル

## 実行タイミング

- プロジェクトの初期構築時

## 手順

### ステップ1: プロジェクト初期化

1. Bun プロジェクトを初期化（backend / frontend）
2. ElysiaJS ・ Next.js のセットアップ
3. Husky / lint-staged / ESLint / Prettier / cspell のセットアップ

### ステップ2: Contextベースのディレクトリ構造生成

要件分析で特定した Context ごとに以下のディレクトリを生成:

```text
backend/src/contexts/[context名]/
├── domain/
├── application/
├── infrastructure/
└── presentation/

frontend/src/contexts/[context名]/
├── components/
├── hooks/
├── types/
└── api/
```

### ステップ3: レイヤー間の制約

- Domain → 外部依存なし
- Application → Domain のみ依存
- Infrastructure → Domain, Application に依存
- Presentation → Application のみ依存
- Context 間の直接依存は禁止（shared 経由のみ）
````

### 4.5 `e2e-testing` - E2Eテストスキル

```markdown
---
name: e2e-testing
description: Playwrightを使用したE2Eテストを作成・実行する。結合テストフェーズで使用。
---

# E2E テストスキル

## 実行タイミング

- 全機能の結合が完了した後

## 手順

### ステップ1: テストシナリオの作成

1. 要件定義書の機能要件からユーザーフローを特定
2. 各フローに対してテストケースを作成

### ステップ2: Playwright テストの実装

1. ブラウザサブエージェントを活用してUIの動作確認
2. テストコードを `e2e/` ディレクトリに配置
3. テストは日本語で命名

### ステップ3: 実行と検証

1. `npx playwright test` で実行
2. 失敗した場合は原因を特定して修正
3. スクリーンショットを保存して結果を報告
```

### 4.6 `self-growth` - 自己成長スキル

````markdown
---
name: self-growth
description: 失敗時にWebで調査し、原因と対処法をファイルに蓄積する。エラー発生時・テスト失敗時に自動適用。
---

# 自己成長スキル（失敗学習）

## 実行タイミング

- テストが失敗したとき
- ビルドエラーが発生したとき
- 実装アプローチが間違っていたとき

## 手順

### ステップ1: 失敗の記録

失敗が発生したら、`.learnings/raw/` に以下の形式でログを保存:

```markdown
# [YYYY-MM-DD] [short-title]

## エラー内容

[what happened]

## 原因

[why it happened]

## Web調査結果

[what was found from web search]

## 対処法

[how it was fixed]

## タグ

[e.g. TypeScript, ElysiaJS, DDD, Playwright]
```
````

### ステップ2: Web調査

1. エラーメッセージや失敗内容でWeb検索する
2. 公式ドキュメントやStack Overflowの情報を収集
3. 根本原因と正しい対処法を特定

### ステップ3: 辞書の更新

`.learnings/raw/` のログが **5件以上** 蓄積されたら、
`.learnings/dictionary.md` を自動生成・更新する:

```markdown
# 📖 対処辞書

## 索引

- [TypeScript](#typescript)
- [ElysiaJS](#elysiajs)
- [Next.js](#nextjs)
- [Playwright](#playwright)
- [DDD](#ddd)

---

## TypeScript

### any 型エラー

- **問題**: ...
- **対処**: ...
- **参照**: [raw/2025-01-15_any-type-error.md]

...
```

## 重要な原則

- ただの作業者ではなく、**失敗から学ぶ**ことを最優先
- 同じ失敗を二度と繰り返さないように辞書を参照する
- 辞書はタグ別に索引を付け、素早く対処法を見つけられるようにする

````

---

## 5. ワークフロー (Workflows) の構築

ワークフローは **複数ステップからなる一連の作業手順** を定義します。
`<root>/.agent/workflows/` に配置します。

### 5.1 `/full-auto-dev` - 完全自動開発ワークフロー（メイン）

```markdown
---
description: 要件定義書から完全自動でアプリを開発するメインワークフロー
---

# 完全自動開発ワークフロー

## 前提

- 要件定義書（Markdown）が提供されている
- 全てを **自然言語で設計してからコードに起こす**
- `parts/*` ブランチでクラス・関数・コンポーネント単位に TDD → `dev` にマージ
- `build` ブランチでパーツを組み立て → `dev` にマージして機能完成
- **スコープ**: `dev` ブランチ上での開発完了まで。`qa` 以降は手動

## 手順

### Phase 1: 要件分析 & DDDリスト作成

// turbo

1. `requirements-analysis` スキルを適用して要件を分析する
2. DDDリスト（Context・エンティティ・VO・サービス）を作成する
3. 分析結果をレビュー用アーティファクトとして出力する

### Phase 2: 自然言語で全体設計

// turbo

4. `clean-architecture` スキルを適用してディレクトリ構造を生成する
5. 分析結果にドメインありと判断された場合、`ddd-modeling` スキルを適用する
6. DDDリストから **関数単位** にリストアップする
7. **共通化できる関数** を自然言語の時点で特定・統合する
8. フロントエンドの **コンポーネントリスト** を作成する（共通→ページ固有の順）

### Phase 3: 実装タスクリスト & parts 計画

// turbo

9. 自然言語設計をもとに実装タスクリストを作成する
10. `parts/*` ブランチ名を決定する（クラス/関数/コンポーネント単位）

★ この時点で実行プランをアーティファクトとして表示 → 確認

### Phase 4: パーツ実装（TDD）→ dev マージ

// turbo

以下のサイクルを繰り返す:

11. `dev` から `parts/[パーツ名]` ブランチを作成する
12. `tdd-implementation` スキルで個別に TDD 実装する
13. 全テスト通過を確認して `dev` にマージする
14. 独立した parts は並列で実装を進める

### Phase 5: 組立（build）→ dev マージ

// turbo

15. `dev` から `build` ブランチを作成する
16. `dev` に集まったパーツを組み立てて機能として動くようにする
17. 結合部分のテストを書いて通す
18. `dev` にマージして機能完成

### Phase 6: Phase 4-5 を繰り返し

// turbo

19. 全機能が `dev` 上で完成するまで Phase 4-5 を繰り返す
20. lint / 型チェック / セキュリティチェックを実施する
21. ウォークスルーで最終結果を報告する

※ `qa`・`main`（テスト・デプロイ）は手動で実施する（スコープ外）
````

### 5.2 `/tdd-cycle` - TDDサイクル

```markdown
---
description: 単一の関数/クラスに対するTDDサイクルを実行する
---

# TDD サイクル

// turbo-all

1. 対象の関数/クラスのインターフェースを定義する
2. テストファイルを作成し、失敗するテストを書く
3. `bun test` でテストが失敗することを確認する
4. テストを通す最小限の実装コードを書く
5. `bun test` でテストが成功することを確認する
6. コードをリファクタリングする
7. `bun test` でテストが引き続き成功することを確認する
```

### 5.3 `/e2e-verify` - E2E検証

```markdown
---
description: E2Eテストを実行し結果を報告する
---

# E2E 検証

// turbo-all

1. `bunx playwright install` でブラウザをインストールする
2. アプリケーションを開発サーバーで起動する
3. `bunx playwright test` でE2Eテストを実行する
4. 失敗したテストがある場合、ブラウザサブエージェントで画面を確認する
5. 失敗原因を特定し修正する
6. 全テストがパスするまで繰り返す
7. テスト結果のスクリーンショットを保存する
```

---

## 6. 並列実行 (Parallel Execution) 戦略

### 6.1 並列実行の概要

Antigravity の **Agent Manager** を使って、複数のエージェントを同時に動かすことができます。  
これにより、独立したタスクを並列で処理し、開発速度を大幅に向上させます。

### 6.2 並列化できるタスク

```
                    ┌─────────────────┐
                    │ 自然言語設計    │
                    │ (直列: Phase1-3)│
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
     ┌────────┴───┐  ┌──────┴──────┐  ┌───┴────────┐
     │ Agent A    │  │ Agent B     │  │ Agent C    │
     │ parts/     │  │ parts/      │  │ parts/     │
     │ user-repo  │  │ order-svc   │  │ user-form  │
     │ TDD実装    │  │ TDD実装     │  │ TDD実装    │
     └────────┬───┘  └──────┬──────┘  └───┬────────┘
              │              │              │
              └──────────────┼──────────────┘
                             │
                    ┌────────┴────────┐
                    │ dev にマージ     │
                    │ (パーツ集積)    │
                    └────────┬────────┘
                             │
                    ┌────────┴────────┐
                    │ build で組立   │
                    │ (機能完成)      │
                    └────────┬────────┘
                             │
                    ┌────────┴────────┐
                    │ dev にマージ     │
                    │ → 繰り返し      │
                    └─────────────────┘
```

### 6.3 並列実行のルール

| ルール                   | 説明                                          |
| :----------------------- | :-------------------------------------------- |
| **独立性**               | 並列実行する parts は互いに依存してはいけない |
| **コンフリクト回避**     | 同一ファイルを複数のエージェントが編集しない  |
| **パーツ単位**           | クラス・関数・コンポーネント単位で分割する    |
| **インターフェース先行** | 並列実行前にインターフェースを確定しておく    |

### 6.4 Agent Manager の活用

1. **メインエージェント（オーケストレーター）**: 全体の計画・管理・ build 組立を担当
2. **サブエージェント A**: `parts/user-repository` で TDD 実装
3. **サブエージェント B**: `parts/order-service` で TDD 実装
4. **サブエージェント C**: `parts/user-form` で TDD 実装

### 6.5 ツール呼び出しの並列実行

エージェント内部でも、依存関係のないツール呼び出しは並列で実行されます。

```
例: 以下のツール呼び出しは同時に実行される
- ファイルAの読み込み ← 独立
- ファイルBの読み込み ← 独立
- Webの検索       ← 独立
```

ワークフロー内で `// turbo` や `// turbo-all` アノテーションを使うことで、コマンド実行を自動承認にでき、更なる高速化が可能です。

---

## 7. ナレッジアイテム (Knowledge Items) の活用

### 7.1 自動蓄積される知見

エージェントとの対話を重ねることで、以下が自動的にナレッジとして蓄積されます:

- **設計パターン**: プロジェクトで採用した設計判断
- **バグの解決策**: 過去に遭遇したバグとその修正方法
- **技術スタックの選定理由**: なぜその技術を選んだか
- **コーディング規約の例外**: ルールの例外として認めたケース

### 7.2 ナレッジを最大活用するコツ

1. **初期段階で方針を明示**: 最初の会話でコーディングスタイルや設計方針を明確に伝える
2. **ミスから学ばせる**: エージェントがミスした場合、なぜ間違いかを説明する → ナレッジに蓄積
3. **別プロジェクトへの展開**: ナレッジはグローバルにも保持されるため、別プロジェクトでも活用可能

---

## 8. MCP 統合

### 8.1 開発で活用すべきMCPサーバー

| サービス            | 用途                              |
| :------------------ | :-------------------------------- |
| **GitHub**          | Issue管理、PR作成、コードレビュー |
| **Supabase / Neon** | DB スキーマの直接参照、クエリ補助 |
| **Linear**          | タスク管理連携（TODO→チケット化） |
| **Firebase**        | デプロイ連携                      |

### 8.2 設定方法

1. サイドパネルの `...` → **MCP Store** を開く
2. 必要なサーバーを **Install**
3. 認証を完了する

> カスタムMCPサーバーが必要な場合は `mcp_config.json` を直接編集する。

---

## 9. 自動開発フロー全体設計

### 核心思想

> **自然言語で全てを設計してから、コードに起こす。**
> 作業者（エージェント）がやることが100%明確になり、判断で迷わない。

### 完全な流れ（ステップバイステップ）

```
[あなた] 要件定義書を渡す
    ↓
[エージェント] /full-auto-dev ワークフローを実行
    ↓
──────── 自然言語フェーズ（コードなし） ────────
    ↓
[Phase 1] 要件分析 & DDDリスト作成
    ↓
[Phase 2] 自然言語で全体設計
    - アーキテクチャ・関数リスト・共通化・コンポーネントリスト
    ↓
[Phase 3] 実装タスクリスト & parts 計画
    ↓
★ 実行プラン（自然言語設計書）を表示 → 確認
    ↓
──────── コードフェーズ（繰り返し） ────────
    ↓
[Phase 4] parts ブランチで個別 TDD
    - dev → parts/user-repository で TDD
    - dev → parts/order-service で TDD
    - dev → parts/user-form で TDD
    - 失敗時は self-growth スキルが自動発動
    - 全テスト通過で dev にマージ（パーツがただ集まる）
    ↓
[Phase 5] build ブランチで組立
    - dev → build でパーツを組み立てる
    - 結合テストを書いて通す
    - dev にマージして機能完成
    ↓
    ↻ Phase 4-5 を全機能完成まで繰り返し
    ↓
[Phase 6] lint / 型 / セキュリティチェック
    ↓
[エージェント] ウォークスルーで最終報告
    - 自然言語設計書 vs 実装の対応表
    - テスト結果
    ↓
──────── ここから先は手動（スコープ外） ────────
    ↓
[あなた] qa ブランチでテスト
    ↓
[あなた] main にマージしてデプロイ 🎉
```

### Git ブランチ戦略

```
main   ← 本番デプロイ
  │
  └── qa    ← テスト環境
       │
       └── dev   ← 開発環境（自動化のスコープはここまで）
            │
            ├── build                ← dev派生。パーツを組み立てる場所
            ├── parts/user-entity    ← dev派生。クラス単位
            ├── parts/user-repo      ← dev派生。クラス単位
            ├── parts/order-service   ← dev派生。関数単位
            ├── parts/user-form      ← dev派生。コンポーネント単位
            └── parts/button         ← dev派生。共通コンポーネント
```

**サイクル:**

```
dev → parts/* で個別TDD → dev にマージ（パーツがただ集まる）
 → build でパーツ組立 → dev にマージ（機能完成）
 → 繰り返し
```

**ルール:**

- `parts/*` はクラス・関数・コンポーネント単位で切る
- `parts/*` 内で TDD サイクルを回し、全テスト通過後に `dev` へマージ
- `build` で集まったパーツを組み立てて動く機能にする
- `qa` 以降は手動（スコープ外）

---

## 10. あなたがやるべきこと（チェックリスト）

### 🔨 即座にやること

- [ ] **`.agent/` ディレクトリを作成**: プロジェクトルートに作成
- [ ] **`.learnings/` ディレクトリを作成**: 失敗学習用ディレクトリ
- [ ] **ルールファイルを配置**: `.agent/rules/` に上記5ファイルを作成
- [ ] **スキルを配置**: `.agent/skills/` に上記6スキルを作成
- [ ] **ワークフローを配置**: `.agent/workflows/` に上記3ワークフローを作成
- [ ] **レビューポリシー設定**: 開発時は `Always Proceed` に設定（設定画面）
- [ ] **サンドボクシング確認**: ON になっていることを確認

### 📋 要件定義書のテンプレート準備

要件定義書は以下のフォーマットにすると、エージェントが最も効率的に処理できます:

```markdown
# [プロジェクト名] 要件定義書

## 概要

[アプリの目的と概要を1-2段落で記述]

## ターゲットユーザー

[想定するユーザー]

## 機能要件

### 機能1: [名称]

- [説明]
- [ユーザーストーリー: 〜として、〜したい、〜のために]

### 機能2: [名称]

- ...

## 非機能要件

- パフォーマンス: [要件]
- セキュリティ: [要件]
- スケーラビリティ: [要件]

## 技術的制約（あれば）

- [制約1]
- [制約2]

## UI/UXの要望（あれば）

- [要望1]
```

### 🧪 テスト動作確認

環境構築後、小さなプロジェクト（例: TODOアプリ）で一連のフローを試す:

1. 簡単な要件定義書を作成
2. `/full-auto-dev` ワークフローを実行
3. 各フェーズが正しく動作するか確認
4. 問題があればスキル/ワークフローを修正
5. ナレッジに学習内容が蓄積されていることを確認

### 🔄 継続的な改善

- エージェントのミスをフィードバックしてナレッジを育てる
- ワークフローの手順で非効率な部分を発見したら更新する
- 新しい設計パターンが必要になったらスキルを追加する
- Claude Code 等他のツールのベストプラクティスも随時取り入れる

---

## 11. 参考情報

### Antigravity 公式ドキュメント（`guide/` ディレクトリ）

| ファイル                      | 概要                              |
| :---------------------------- | :-------------------------------- |
| `スキル.md`                   | スキルの作成・配置・活用サイクル  |
| `ルール.md`                   | ルール・ワークフロー・@メンション |
| `タスクグループ.md`           | 大規模タスクの分割管理            |
| `タスクリスト.md`             | エージェントのアクションプラン    |
| `ナレッジ.md`                 | 永続メモリシステム                |
| `MCP接続.md`                  | 外部サービス連携                  |
| `ブラウザサブエージェント.md` | ブラウザ操作の専用アシスタント    |
| `実行プラン.md`               | 実装前の設計図レビュー            |
| `ウォークスルー.md`           | 変更点のまとめ報告                |
| `サンドボクシング.md`         | ターミナル隔離のセキュリティ      |
| `ストリクトモード.md`         | 厳格なセキュリティモード          |

### 外部参考情報

| トピック                           | ポイント                                                                                                 |
| :--------------------------------- | :------------------------------------------------------------------------------------------------------- |
| **Claude Code ベストプラクティス** | Plan→Act→Reflect のフレームワーク、コンテキスト分離、サブエージェント活用                                |
| **AIエージェント×TDD**             | テストを先に書かせて「Red」を作り、次に「Green」を作らせる。テストが明確なゴールになるためAIと相性が良い |
| **クリーンアーキテクチャ×AI**      | レイヤー分離により並列実装が可能。各層を独立にテスト可能                                                 |
| **並列エージェント**               | 独立タスクを分離し、コンフリクトを避けて並列実行。インターフェースを先に確定することが鍵                 |

---

> **次のステップ**: このドキュメントの内容に同意できたら、「環境を構築して」と指示してください。  
> 上記のディレクトリ構造、ルール、スキル、ワークフローを全て自動で生成します。
